<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta content="text/html; charset=UTF-8" http-equiv="content-type" />
<title>OW Custom game balancer</title>
<meta name="description" content="Overwatch custom game balancer">
<style>

html {
	height: 100%;
}

body {
	margin: 1em;
	height: 95%;
}

.page-title {
	font-size: 26pt;
	display: inline-block;
	padding-bottom: 0.5em;
}

.copyright {
	float: right;
	display: inline;
}

.team-title {
	font-size: 20pt;
	border: none;
}

.table {
    display: table;
	max-height: 100%;
	
}

.row {
    display: table-row;
}

.cell {
	display: table-cell;
}

.teams {
	border-collapse: separate;
	border-spacing: 10px 5px;
}

.team {
	border: 1px solid black;
	background-color: lightgray;
	border-collapse: separate;
	border-spacing: 5px 5px;
	min-width: 20em;
}

.player-item {
	background-color: white;
	cursor: grab;
}

.team-captain {
	background-color: PaleGreen;
}

.player-highlighted {
	animation-name: highlight;
    animation-duration: 1s;
    animation-iteration-count: 1;
}

@keyframes highlight {
    50%  {background-color: Gold;}
}

.empty-player {
	cursor: default;
}

.player-item:active {
	cursor: grabbing;
}

.player-icon {
	display: inline-block;
	text-align: center;
	vertical-align: middle;
	line-height: 80%;
}

.icon-image {
	display: inline;
}

.rank-icon {
	width: 24px;
}

.icon-sr {
	display: inline;
	font-size: 8pt;
}

.player-name {
	display: inline;
	font-size: 16pt;
}

.player-selected {
	background-color: blue;
	color: white;
}

.team-selecor {
	margin-left: 1em;
}

.team_btn {
	float: right;
	font-size: 70%;
}

.lobby-container {
	position: relative;
	top: 0;
	bottom: 0;
	overflow-y: auto;
	max-height: 33em;
	padding-right: 1.2em;
	overflow-x: hidden;
}

.trashcan {
    display: inline-block;
    border: 1px dashed black;
    vertical-align: middle;
    width: 100%;
	line-height: 2em;
	text-align: center;
	font-size: 16pt;
}

.big-btn {
	font-size: 16pt;
	line-height: 2em;
	vertical-align: middle;
	width: 100%;
}

.team-toolbar {
	display: inline-block;
	width: 100%;
}

.sr-edit {
	padding: 0;
	font-size: 8pt;
}

.tips {
	background-color: lightgreen;
	border-radius: 1em;
	padding: 1em;
	margin-left: 5em;
	max-width: 25em;
	min-width: 20em;
}

ul {
	padding-inline-start: 1em;
}

li {
	margin-bottom: 0.4em;
}

.class-icon {
	height: 1.2em;
	float: right;
	filter: opacity(60%);
}

.secondary-class {
	height: 0.9em;
	filter: opacity(40%);
}

.dlg {
	position: fixed;
	left: 0px;
	top: 0px;
	width: 100%;
	height: 100%;
	text-align: center;
	vertical-align: middle;
}

.dlg-background {
	background-color: black;
	position: fixed;
	left: 0px;
	top: 0px;
	width: 100%;
	height: 100%;
	opacity: 0.5;
}

.dlg-container {
	position: absolute;
	left: 50%;
	top: 50%;
}

.dlg-content {
	position: absolute;
	transform: translate(-50%,-50%);
	z-index: 20;
	background-color: white;
	padding: 2em;
	padding-top: 0.5em;
	box-shadow: 5px 5px 15px black;
	
}

textarea {
	text-align: left;
}

.dlg_options {
	text-align: left;
	padding-left: 2em;
	border-collapse: separate;
	border-spacing: 0.5em;
	white-space: nowrap;
}

.filter {
	border: 1px solid;
	margin-bottom: 5px;
}

.filter-active {
	outline: none;
	box-shadow: 0 0 10px #9ecaed;
}

.group {
	border: 1px solid gray;
	max-width: 20em;
}

.group-header {
	background-color: lightgray;
	user-select: none;
	cursor: pointer;
	font-size: 120%;
	padding: 0.2em;
}

.header-icon {
	display: inline-block;
	width: 1em;
	height: 1em;
	border: 1px solid gray;
	font-weight: bold;
	text-align: center;
	margin-right: 0.2em;
	line-height: 1em;
}

.header-icon span {
	vertical-align: middle;
}

.group-content {
	padding: 0.2em;
}
	
.subgroup {
	margin-left: 1em;
}

.group-collapsed {
	display:none;
}

input.percent {
	width: 3em;
}

input[readonly] {
	border: none;
}

.dlg-edited-mark {
	visibility: hidden;
	cursor: default;
	color: blue;
	font-weight: bold;
}

.hero-icon-list {
	
}

.hero-icon {
	display: inline;
	height: 64px;
	margin-right: 0.5em;
}

</style>

<script language="JavaScript" type="text/javascript">
var selected_player_team1 = "";
var selected_player_team2 = "";
var team1 = [];
var team2 = [];
var lobby = [];
var team_size = 6;
var region = "eu";
var current_player_edit = "";
var team1_captain = "";
var team2_captain = "";

// variables for recursive team balancer
var balance_team_combinations = [];
var current_team_combination = [];
var active_players = [];
var active_players_total_sr = 0;
var best_btf = 0;
var best_btf_index = 0;
var balance_max_sr_diff = 1000;
var balance_exclude_classes = [ "defence" ];

// hero list for calculating main classes
var hero_classes = {
	reaper:		"offence",
	pharah:		"offence",
	soldier76:	"offence",
	genji:		"offence",
	tracer:		"offence",
	sombra:		"offence",
	mccree:		"offence",
	
	torbjorn:	"defence",
	hanzo:		"defence",
	mei:		"defence",
	bastion:	"defence",
	widowmaker:	"defence",
	junkrat:	"defence",
	
	mercy:		"support",
	ana:		"support",
	lucio:		"support",
	zenyatta:	"support",
	symmetra:	"support",
	
	dva:		"tank",
	orisa:		"tank",
	winston:	"tank",
	zarya:		"tank",
	roadhog:	"tank",
	reinhardt:	"tank",
};
var class_names = [
	"offence",
	"defence",
	"support",
	"tank"
];

// player stats fetcher
var players_for_update = [];
var total_playets_for_update = 0;
var min_api_request_interval = 5000; //milliseconds
var top_class_min_fraction = 0.25; // fraction of overall time played
var top_hero_max_ratio = 3.0; // ratio of hero playtime to detect top heroes

// OWAPI interface object
// usage: 
// 1. set id to player BattleTag
// 2. set onSuccess and onFail callback functions
// 3. call getStats() method
// 4. object field filled with stats. Read them in onSuccess callback or process error in onFail
var OWAPI = {
	id: "", // player battletag
	display_name: "", // first part of battletag before '#'
	sr: 0,
	level: 0,
	time_played: 0,
	top_classes: [],
	top_heroes: [],
	
	onSuccess: undefined, // Set to actual callback function before use
	onFail: undefined, // Set to actual callback function before use
	
	getStats: function() {
		// reset
		this.sr = 0;
		this.level = 0;
		this.time_played = 0;
		this.top_classes = [];
		this.top_heroes = [];
		
		this.id = this.id.trim().replace("#", "-");
		this.display_name = this.id.slice( 0, this.id.search("-") );
	
		var xhttp = new XMLHttpRequest();
		xhttp.onreadystatechange = function() {
			if (this.readyState == 4 ) {
				if ( this.status == 200) {
					try {
						var stats_obj = JSON.parse(this.responseText);
						if ( stats_obj[region] === null ) {	
							throw "Player has no stats in region "+region.toUpperCase();
						}
						OWAPI.sr = Number(stats_obj[region].stats.competitive.overall_stats.comprank);
						OWAPI.level = stats_obj[region].stats.competitive.overall_stats.prestige*100 + stats_obj[region].stats.competitive.overall_stats.level,
						OWAPI.time_played = Number(stats_obj[region].stats.competitive.game_stats.time_played);
						
						var hero_stats = OWAPI.parseHeroStats( stats_obj[region].heroes );
						OWAPI.top_classes = OWAPI.calculateTopClasses( hero_stats );
						OWAPI.top_heroes = OWAPI.calculateTopHeroes( hero_stats );
						
						OWAPI.onSuccess.call();					
					}
					catch (err) {
						if(typeof OWAPI.onFail == "function") {
							OWAPI.onFail.call( err.message );
						}
					}
						
				} else {
					var msg = "";
					switch (this.status) {
						case 404: msg = "Player not found (incorrect BattleTag)"; break;
						case 429: msg = "Too many stats requests, try later"; break;
						default: msg = "Can't get player stats (HTTP "+this.status+": "+this.statusText+")";
					}
					if(typeof OWAPI.onFail == "function") {
						OWAPI.onFail.call( OWAPI, msg );
					}
				}
			}
		};
		xhttp.open("GET", "https://owapi.net/api/v3/u/"+this.id+"/blob", true);
		xhttp.send();
	},
	
	// returns array of objects (hero, playtime) sorted by playtime
	parseHeroStats: function( heroes_node ) {
		var hero_playtime = heroes_node.playtime.competitive;
		
		var hero_playtime_sorted = [];
		for (var hero_name in hero_playtime ) {
			hero_playtime_sorted.push( { hero: hero_name, playtime: Math.round(hero_playtime[hero_name],1)} );
		}
		
		hero_playtime_sorted.sort( function(hero1, hero2) {
				return hero2.playtime - hero1.playtime;
			});
			
		return hero_playtime_sorted;
	},
	
	// returns top 2 hero classes
	calculateTopClasses: function calculate_top_classes( hero_playtime ) {
		var class_playtime = {
			offence: 0,
			defence: 0,
			tank: 0,
			support: 0
			};
		
		for ( i=0; i<hero_playtime.length; i++ ) {
			var hero_class = hero_classes[hero_playtime[i].hero];
			class_playtime[hero_class] += hero_playtime[i].playtime;
		}
		
		var class_playtime_arr = Object.entries(class_playtime);
		class_playtime_arr.sort( function(item1, item2){
				return item2[1]-item1[1];	
			});
		
		var top_classes = [];
		var top_class = class_playtime_arr.shift();
		if( top_class !== undefined ) {
			top_classes.push( top_class[0] );
		}
		top_class = class_playtime_arr.shift();
		if( top_class !== undefined ) {
			if( Number(top_class[1])/this.time_played >= top_class_min_fraction ) {
				top_classes.push( top_class[0] );
			}
		}
		
		return top_classes;
	},
	
	// returns top 4 heroes by playtime
	calculateTopHeroes: function ( hero_playtime ) {
		var top_heroes = [];
		if ( hero_playtime.length != 0 ) {
			top_heroes.push( hero_playtime[0] );
		}
		
		for ( i=1; i<hero_playtime.length; i++ ) {
			if (  hero_playtime[i-1].playtime / hero_playtime[i].playtime < top_hero_max_ratio ) {
				top_heroes.push( hero_playtime[i] );
			} else {
				break;
			}
		}
			
		while (top_heroes.length > 4) {
			top_heroes.pop();
		}
		
		return top_heroes;
	}
}


/*
*		UI functions
*/

function draw_player( player_struct, team_id ) {
	var text_node;
	var br_node;
	
	var team_list = document.getElementById(team_id);
	
	var new_player_item_row = document.createElement("div");
	new_player_item_row.className = "row ";
	
	var new_player_item = document.createElement("div");
	new_player_item.className = "cell player-item";
	new_player_item.id = player_struct.id;
	if( ! player_struct.empty) {
		new_player_item.title = player_struct.id + "\nLevel: " + player_struct.level;
	}
	if ( Array.isArray(player_struct.top_heroes) ) {
		new_player_item.title += "\nTop heroes: ";
		for( i=0; i<player_struct.top_heroes.length; i++ ) {
			new_player_item.title += player_struct.top_heroes[i].hero;
			if ( i< player_struct.top_heroes.length-1) {
				new_player_item.title += ", ";
			}
		}
	}
	new_player_item.onclick = function(){player_item_onclick(this, team_id);};
	if( ! player_struct.empty) {
		new_player_item.draggable = true;
	}
	new_player_item.ondragstart = function(event){player_drag(event);};
	new_player_item.ondrop = function(event){player_drop(event);};
	new_player_item.ondragover = function(event){player_allowDrop(event);};
	new_player_item.ondblclick = function(event){player_dblClick(event);};
	new_player_item.oncontextmenu = function(event){player_contextmenu(event);};
	new_player_item_row.appendChild(new_player_item);
	
	// captain mark
	var team_captain = "";
	if ( team_id == "team1") {
		team_captain = team1_captain;
	} else {
		team_captain = team2_captain;
	}
	if( (player_struct.empty !== true) && (player_struct.id == team_captain) ) {
		new_player_item.classList.add("team-captain");
		new_player_item.title = "Team captain\n"+new_player_item.title;
	}
	
	// rank icon
	var player_icon = document.createElement("div");
	player_icon.className = "player-icon";
	
	var icon_image = document.createElement("div");
	icon_image.className = "icon-image";
	
	var img_node = document.createElement("img");
	img_node.className = "rank-icon";
	var rank_name = get_rank_name(player_struct.sr);
	img_node.src = "rank_icons/"+rank_name+"_small.png";
	img_node.title = rank_name;
	icon_image.appendChild(img_node);
	player_icon.appendChild(icon_image);
	
	br_node = document.createElement("br");
	player_icon.appendChild(br_node);
	
	// SR value
	var icon_sr = document.createElement("div");
	icon_sr.className = "icon-sr";
	
	var sr_display = document.createElement("span");
	sr_display.id = "sr_display_"+player_struct.id;
	var sr_text = player_struct.sr;
	if( player_struct.empty ) {
		sr_text = '\u00A0';
		new_player_item.classList.add("empty-player");
	}
	text_node = document.createTextNode( sr_text );
	sr_display.appendChild(text_node);
	sr_display.appendChild(text_node);
	icon_sr.appendChild(sr_display);
	
	player_icon.appendChild(icon_sr);
	
	new_player_item.appendChild(player_icon);
	
	// space after rank icon
	text_node = document.createTextNode("\u00A0");
	new_player_item.appendChild(text_node)
	
	// player name
	var player_name = document.createElement("div");
	player_name.className = "player-name";
	
	var name_display = document.createElement("span");
	name_display.id = "name_display_"+player_struct.id;
	text_node = document.createTextNode(player_struct.display_name);
	name_display.appendChild(text_node);
	player_name.appendChild(name_display);
	
	new_player_item.appendChild(player_name);
	
	// class icons
	if ( player_struct.top_classes !== undefined ) {
		for(var i=0; i<player_struct.top_classes.length; i++) {
			var class_icon = document.createElement("img");
			class_icon.className = "class-icon";
			if( i != 0 )  {
				class_icon.className += " secondary-class";
			}
			class_icon.src = "class_icons/"+player_struct.top_classes[i]+".png";
			class_icon.title = player_struct.top_classes[i];
			new_player_item.appendChild(class_icon);
		}
	}
	
	team_list.appendChild(new_player_item_row);
}

function redraw_teams() {
	document.getElementById("team1").innerHTML = "";
	document.getElementById("team2").innerHTML = "";
	document.getElementById("lobby").innerHTML = "";

	for( var i=0; i<team1.length; i++) {
		draw_player( team1[i], "team1" );
	}
	// add empty players up to max team size
	for( i=team1.length; i<team_size; i++) {
		draw_player(  create_empty_player(), "team1" );
	}

	for( var i=0; i<team2.length; i++) {
		draw_player( team2[i], "team2" );
	}
	for( i=team2.length; i<team_size; i++) {
		draw_player( create_empty_player(), "team2" );
	}
	
	for( var i=0; i<lobby.length; i++) {
		draw_player( lobby[i], "lobby" );
	}
	for( i=lobby.length; i<team_size; i++) {
		draw_player( create_empty_player(), "lobby" );
	}
	
	document.getElementById("lobby_count").innerHTML = lobby.length;
		
	update_teams_sr();
	
	save_players_list();
}

function collapse_group( header ) {
	header.classList.toggle("header-expanded");
	var group_expanded = header.classList.contains("header-expanded");
	
	var header_icon = header.getElementsByClassName("header-icon")[0];
	if (group_expanded) {
		header_icon.innerHTML = "<span>-</span>";
	} else {
		header_icon.innerHTML = "<span>+</span>";
	}
		
	var group_content = header.parentElement.getElementsByClassName("group-content");
	for (var i=0; i<group_content.length; i++ ) {
		group_content[i].classList.toggle("group-collapsed");
	}
}

function lobby_filter_change() {
	var filter_value = document.getElementById("lobby_filter").value.toLowerCase();
	if (filter_value != "") {
		document.getElementById("lobby_filter").classList.add("filter-active");
	} else {
		document.getElementById("lobby_filter").classList.remove("filter-active");
	}
	
	for( var i=0; i<lobby.length; i++) {
		if ( filter_value == "" || lobby[i].display_name.toLowerCase().includes( filter_value ) || lobby[i].id.toLowerCase().includes( filter_value ) ) {
			document.getElementById(lobby[i].id).parentElement.style.display = "table-row";
		} else {
			document.getElementById(lobby[i].id).parentElement.style.display = "none";
		}
	}
}

function new_player_keyup(ev) {
	ev.preventDefault();
    if (ev.keyCode == 13) { //enter pressed
        add_player_click();
    }
}

function highlight_player( player_id ) {
	document.getElementById(player_id).classList.toggle("player-highlighted", true);
	setTimeout( reset_highlighted_players, 2000 );
}

function highlight_players( player_id_list ) {
	for( i=0; i<player_id_list.length; i++ ) {
		document.getElementById(player_id_list[i]).classList.toggle("player-highlighted", true);
	}
	
	setTimeout( reset_highlighted_players, 2000 );
}

function reset_highlighted_players() {
	var elems = document.getElementsByClassName( "player-highlighted" );
	for( i=0; i<elems.length; i++ ) {
		elems[i].classList.toggle("player-highlighted", false);
	}
}

/*
*		Player stats functions
*/

function calc_player_sr( player ) {
	var player_sr = player.sr;
	if (document.getElementById("balance_adjust_sr").checked) {
		if ( player.top_classes !== undefined ) {
			var top_class = player.top_classes[0];
			if( top_class !== undefined ) {
				player_sr = Math.round( player_sr * Number(document.getElementById("balance_adjust_sr_"+top_class).value)/100 );
			}
		}
	}
	return player_sr;
}

function get_rank_name( sr ) {
	if (sr == 0) {
		return "unranked"
	} else if ( sr < 1500) {
		return "bronze";
	} else if ( sr < 2000 ) {
		return "silver";
	} else if ( sr < 2500 ) {
		return "gold";
	} else if ( sr < 3000 ) {
		return "platinum";
	} else if ( sr < 3500 ) {
		return "diamond";
	} else if ( sr < 4000 ) {
		return "master";
	} else if ( sr < 5000 ) {
		return "grandmaster";
	} else {
		return "unranked";
	}
}

function calculate_team_sr( team, use_balance_options=false ) {
	var team_sr = 0;
	if (team.length > 0) {
		for( var i=0; i<team.length; i++) {
			var player_sr = team[i].sr;
			if (use_balance_options) {
				player_sr = calc_player_sr( team[i] );
			}
			team_sr += player_sr;
		}
		team_sr = Math.round(team_sr / team.length);
	}
	return team_sr;
}

function update_next_player_stats( ) {
	if ( players_for_update.length > 0 ) {
		var current_player = players_for_update[0];
		document.getElementById("update_stats_btn").value = "↻ Updating stats..."+(total_playets_for_update-players_for_update.length+1)+" / "+total_playets_for_update;
		
		OWAPI.id = current_player.id;
		OWAPI.onSuccess = update_player_success;
		OWAPI.onFail = update_player_fail;
		OWAPI.getStats();
	} else {
		// all players updated
		alert("All stats updated");
		document.getElementById("update_stats_btn").disabled = false;
		document.getElementById("dlg_update_player_stats").disabled = false;
		document.getElementById("update_stats_btn").value = "↻ Update stats";
		redraw_teams();
		fill_player_stats_dlg();
	}
}

function update_player_success() {
	var player = players_for_update.shift();
	
	player.level = OWAPI.level;
	
	if( document.getElementById("update_sr").checked ) {
		// check if SR was manually edited and update option checked
		if ( (player.se !== true) || document.getElementById("update_edited_fields").checked ) {
			player.sr = OWAPI.sr;
			player.se = false;
		}
	}
	
	if( document.getElementById("update_class").checked ) {
		// check if class was manually edited and update option checked
		if ( (player.ce !== true) || document.getElementById("update_edited_fields").checked ) {
			player.top_classes = OWAPI.top_classes;
			player.ce = false;
		}
	}
	
	player.top_heroes = OWAPI.top_heroes;
	
	setTimeout( update_next_player_stats, min_api_request_interval );
}

function update_player_fail( msg ) {
	players_for_update.shift();
	if( confirm( "Error on updating player "+OWAPI.id+": "+msg+". Continue updating stats?" ) ) {
		setTimeout( update_next_player_stats, min_api_request_interval );
	} else {
		document.getElementById("update_stats_btn").disabled = false;
		document.getElementById("dlg_update_player_stats").disabled = false;
		document.getElementById("update_stats_btn").value = "↻ Update stats";
		redraw_teams();
	}
}

function update_all_stats() {
	players_for_update.splice( 0, players_for_update.length );
	players_for_update = lobby.concat(team1).concat(team2);
	total_playets_for_update = players_for_update.length;
	
	var time_needed = Math.round( (min_api_request_interval+2000)*players_for_update.length / 1000 );
	if ( !confirm("Updating all players stats will take about "+time_needed+" seconds due to request interval restrictions.") ) {
		return;
	};

	document.getElementById("update_stats_btn").disabled = true;
	document.getElementById("update_stats_btn").value = "↻ Updating stats...1"+" / "+total_playets_for_update;
	
	update_next_player_stats();
}


/*
*		Player selection and transfer functions
*/

function player_item_onclick(item, team_id) {
	var prev_selected_id = "";
	if (team_id == "team1") {
		prev_selected_id = selected_player_team1;
		selected_player_team1 = "";
	} else if (team_id == "team2") {
		prev_selected_id = selected_player_team2;
		selected_player_team2 = "";
	} else {
		return;
	}

	if (prev_selected_id != "" ) {
		var prev_selected = document.getElementById(prev_selected_id);
		prev_selected.classList.toggle("player-selected");
	}

	if (prev_selected_id != item.id) {
		if (item.id != "") {
			item.classList.toggle("player-selected");
		}
	
		if (team_id == "team1") {
			selected_player_team1 = item.id;
		} else {
			selected_player_team2 = item.id;
		}
	}
	
	if (selected_player_team1!="" && selected_player_team2!="") {
		document.getElementById("swap_btn").disabled = false;
	} else {
		document.getElementById("swap_btn").disabled = true;
	}
	
}

function player_drag(ev) {
	 ev.dataTransfer.setData("text/plain", ev.currentTarget.id);
	 ev.dataTransfer.effectAllowed = "move";
	 ev.dropEffect = "move";
}

function player_allowDrop(ev) {
    ev.preventDefault();
	ev.dataTransfer.dropEffect = "move";
}

function player_drop(ev) {
    ev.preventDefault();
	ev.stopPropagation();
	
    var dragged_id = ev.dataTransfer.getData("text");
	var target_id = ev.currentTarget.id;
	if (dragged_id == target_id) {
		return false;
	}
	
	var drag_action = "swap";
	
	if( target_id == "trashcan" ) {
		drag_action = "remove";
		target_id = "";
	}
	
	// find team and index in team for both players 
	var dragged_team;
	var dragged_index;
	var dragged_player;
	var target_team;
	var target_index;
	var target_player;
	
	for( var i=0; i<team1.length; i++) {
		if ( dragged_id == team1[i].id) {
			dragged_team = team1;
			dragged_index = i;
			dragged_player = team1[i];
		}
		if ( target_id == team1[i].id) {
			target_team = team1;
			target_index = i;
			target_player = team1[i];
		}
	}
	for( var i=0; i<team2.length; i++) {
		if ( dragged_id == team2[i].id) {
			dragged_team = team2;
			dragged_index = i;
			dragged_player = team2[i];
		}
		if ( target_id == team2[i].id) {
			target_team = team2;
			target_index = i;
			target_player = team2[i];
		}
	}
	for( var i=0; i<lobby.length; i++) {
		if ( dragged_id == lobby[i].id) {
			dragged_team = lobby;
			dragged_index = i;
			dragged_player = lobby[i];
		}
		if ( target_id == lobby[i].id) {
			target_team = lobby;
			target_index = i;
			target_player = lobby[i];
		}
	}
	
	// dropped on empty slot
	if (target_id == "") {
		var parent_id = ev.currentTarget.parentElement.parentElement.id;
		if (parent_id == "lobby") {
			target_team = lobby;
			target_index = lobby.length;
		} else if (parent_id == "team1") {
			target_team = team1;
			target_index = team1.length;
		} else {
			target_team = team2;
			target_index = team2.length;
		}
		
		if ( dragged_team == target_team ) {
			target_index = target_team.length - 1;
		}
	}
	
	if ((target_team == lobby) && (dragged_team != lobby)) {
		drag_action = "move"; 
	}
	
	if (drag_action == "move") {
		// move dragged player to target team (lobby)
		target_team.splice(target_index, 0, dragged_player);
		dragged_team.splice(dragged_index, 1);
	} else {
		if (target_id == "") {
			// remove dragged player from source team
			dragged_team.splice(dragged_index, 1);
		} else {
			// replace dragged player with target
			dragged_team[dragged_index] = target_player;
		}
	}
	
	if (drag_action == "swap") {
		// replace target with dragged player
		target_team[target_index] = dragged_player;
	}
	
	update_captains();
	
	redraw_teams();
}

function player_dblClick(ev) {
	var selected_id = ev.currentTarget.id;
	
	if (selected_id == "") {
		return;
	}

	// detect selected team
	var selected_team;
	var parent_id = ev.currentTarget.parentElement.parentElement.id;
	if (parent_id == "lobby") {
		selected_team = lobby;
	} else if (parent_id == "team1") {
		selected_team = team1;
	} else {
		selected_team = team2;
	}
	
	// find index in team for player
	var selected_index;
	var selected_player;
	for( var i=0; i<selected_team.length; i++) {
		if ( selected_id == selected_team[i].id) {
			selected_index = i;
			selected_player = selected_team[i];
		}
	}
	
	// detect target team
	var new_team;
	if (selected_team == lobby) {
		if (team1.length < team_size) {
			new_team = team1;
		} else {
			new_team = team2;
		}
	} else {
		new_team = lobby;
	}
	
	// check if team has free slots
	if ( (new_team != lobby) && (new_team.length >= team_size) ) {
		alert("Team is full");
		return;
	}
	
	// move player
	new_team.push( selected_player );
	selected_team.splice(selected_index, 1);
	
	// clear selection
	selected_player_team1 = "";
	selected_player_team2 = "";
	
	update_captains();
	
	redraw_teams();
}

function swap_players() {
	var player1;
	var player1_index;
	for( var i=0; i<team1.length; i++) {
		if (team1[i].id == selected_player_team1) {
			player1 = team1[i];
			player1_index = i;
			break;
		}
	}
	var player2;
	var player2_index;
	for( var i=0; i<team2.length; i++) {
		if (team2[i].id == selected_player_team2) {
			player2 = team2[i];
			player2_index = i;
			break;
		}
	}
	
	team1[player1_index] = player2;
	team2[player2_index] = player1;
	
	selected_player_team1 = "";
	selected_player_team2 = "";
	
	update_captains();
	
	redraw_teams();
	
	document.getElementById("swap_btn").disabled = true;
}

function update_captains() {
	if ( ! document.getElementById("balance_enable_captains").checked ) {
		return;
	}
	
	if ( team1.length > 0 ) {
		team1_captain = team1[0].id;
	} else {
		team1_captain = "";
	}
	
	if ( team2.length > 0 ) {
		team2_captain = team2[0].id;
	} else {
		team2_captain = "";
	}
}


/*
*		Team management functions
*/

function move_team_to_lobby(team) {
	lobby = lobby.concat(team);
	team.splice( 0, team.length );
	update_captains();
}

function clear_team( team ) {
	if( confirm("Clear team?") ) {
		team.splice( 0, team.length );
	}
	update_captains();
}

function sort_team( team, sort_field = 'sr' ) {
	team.sort( function(player1, player2){
			if( typeof player1[sort_field] === 'string') {
				var val1 = player1[sort_field].toLowerCase();
				var val2 = player2[sort_field].toLowerCase();
				return ( val1<val2 ? -1 : (val1>val2?1:0) );
			} else {
				return player2[sort_field] - player1[sort_field];
			}
		} );

	// move captains back to index 0
	if ( document.getElementById("balance_enable_captains").checked && (team != lobby) ) {
		var captain_id = "";
		if ( team == team1 ) {
			captain_id = team1_captain;
		} else {
			captain_id = team2_captain;
		}
		var captain_index = -1;
		for (i=0; i<team.length; i++) {
			if (team[i].id == captain_id) {
				captain_index = i;
				break;
			}
		}
		var captain = team.splice(captain_index, 1)[0];
		team.splice( 0, 0, captain );
	}
}

function update_teams_sr() {
	document.getElementById("team1_sr").innerHTML = calculate_team_sr(team1);
	document.getElementById("team2_sr").innerHTML = calculate_team_sr(team2);
}


/*
*		Player editing and updating
*/

function player_contextmenu(ev) {
	ev.preventDefault();
	
	var player_id = ev.currentTarget.id;
	var player_struct = find_player_by_id(player_id);
	
	current_player_edit = player_id;
	
	init_popup_dlg();
	document.getElementById("popup_dlg").style.display = "block";
	document.getElementById("dlg_title").innerHTML = player_struct.display_name;
	document.getElementById("dlg_player_edit").style.display = "block";
	document.getElementById("dlg_class_select").style.display = "block";
	document.getElementById("dlg_top_heroes").style.display = "block";
	document.getElementById("dlg_update_player_stats").style.display = "block";
	
	fill_player_stats_dlg();
	
	document.getElementById("dlg_ok").onclick = function(event){close_dialog();change_player();};
	
	// disable context menu
	return false;
}

function change_player() {
	if (current_player_edit == "") {
		return;
	}
	
	var player_struct = find_player_by_id(current_player_edit);
	
	var new_name = document.getElementById("dlg_player_display_name").value;
	if ( player_struct.display_name != new_name ) {
		player_struct.ne = true; // name edited
	}
	player_struct.display_name = new_name;
	
	var new_sr = Number(document.getElementById("dlg_player_sr").value);
	if ( player_struct.sr != new_sr ) {
		player_struct.se = true; // sr edited
	}
	player_struct.sr = new_sr;
	
	var top_classes = [];
	top_classes.push( document.getElementById("dlg_main_class").value );
	if ( document.getElementById("dlg_secondary_class").value !== "" ) {
		top_classes.push( document.getElementById("dlg_secondary_class").value );
	}
	if ( player_struct.top_classes.length != top_classes.length ) {
		player_struct.ce = true; // class edited
	} else {
		for (i in top_classes) {
			if ( top_classes[i] != player_struct.top_classes[i] ) {
				player_struct.ce = true;
				break;
			}
		}
	
	}
	player_struct.top_classes = top_classes;
	
	current_player_edit = "";
	
	redraw_teams();
}

function update_current_player_stats() {
	if (current_player_edit == "") {
		return;
	}
	var player_struct = find_player_by_id(current_player_edit);
	
	players_for_update.splice( 0, players_for_update.length );
	players_for_update.push( player_struct );
	total_playets_for_update = players_for_update.length;
	
	document.getElementById("update_stats_btn").disabled = true;
	document.getElementById("dlg_update_player_stats").disabled = true;
	document.getElementById("update_stats_btn").value = "↻ Updating stats...1"+" / "+total_playets_for_update;
	
	update_next_player_stats();
}


/*
*		Team balancer functions
*/

// calculates uneveness of class distribution across teams
// return value: measure of uneveness, 0 = even (perfect) class distribution
function calc_class_unevenness( temp_team1, temp_team2 ) {
	var temp_teams = [temp_team1, temp_team2];
	
	var team_class_unevenness = [];
	var total_class_count = {};
	
	for( p in active_players) {
		for( c=0; c<active_players[p].top_classes.length; c++ ) {
			if ( total_class_count[active_players[p].top_classes[c]] === undefined ) {
				total_class_count[active_players[p].top_classes[c]] = 0;
			}
			total_class_count[active_players[p].top_classes[c]] += 1 / (c+1);
		}
	}
		
	for( t in temp_teams ) {
		var current_class_count = new Object();
		for ( c in class_names ) {
			current_class_count[class_names[c]] = 0;
		}
		
		for( p in temp_teams[t]) {
			for( c=0; c<temp_teams[t][p].top_classes.length; c++ ) {
				current_class_count[temp_teams[t][p].top_classes[c]] += 1 / (c+1);
			}
		}
		
		var current_class_unevenness = Object.create( total_class_count );
		
		var total_class_unevenness = 0;
		for ( var c in total_class_count ) {
			if (balance_exclude_classes.indexOf(c) != -1 ) continue;
		
			if ( total_class_count[c] != 0 ) {
				current_class_unevenness[c] = Math.abs( 100*(current_class_count[c] - (total_class_count[c]/2)) / (total_class_count[c]/2) );
			} 
			total_class_unevenness += current_class_unevenness[c];
		}
		
		team_class_unevenness.push(total_class_unevenness);
	};
	
	avg_class_unevenness = team_class_unevenness.reduce( function(total, num) {return total + num;} ) / team_class_unevenness.length;
	
	return Math.round( avg_class_unevenness, 1 );
}

// checks if current composition variant meets restrictions
// return value: boolean, true if all restrictions passed
function check_balance_restrictions( temp_team1, temp_team2 ) {
	if ( document.getElementById("balance_separate_otps").checked ) {
		var temp_teams = [temp_team1, temp_team2];
		for( t in temp_teams ) {
			// array of one-trick ponies (hero names) in current team
			var current_team_otps = []; 
			for( p in temp_teams[t]) {
				if ( temp_teams[t][p].top_heroes.length == 1 ) {
					var current_otp = temp_teams[t][p].top_heroes[0].hero;
					if (current_team_otps.indexOf(current_otp) == -1) {
						current_team_otps.push( current_otp );
					} else {
						return false;
					}
				}
			}
		}
	}
	
	if ( document.getElementById("balance_enable_captains").checked ) {
		// captains must stay in their teams
		var captain1_found = false;
		for( p in temp_team1) {
			if (temp_team1[p].id == team1_captain) {
				captain1_found = true;
				break;
			}
		}
		if ( ! captain1_found ) {
			return false;
		}
		
		var captain2_found = false;
		for( p in temp_team2) {
			if (temp_team2[p].id == team2_captain) {
				captain2_found = true;
				break;
			}
		}
		if ( ! captain2_found ) {
			return false;
		}
	}
	
	return true;
}

function generate_team_combination(last) {
	if (current_team_combination.length == team_size) {
		// composition is ready, store to list
		var new_composition_players = current_team_combination.slice();
		
		var opposite_team = [];
		for( i in active_players ) {
			if ( new_composition_players.indexOf(active_players[i]) == -1 ) {
				opposite_team.push(active_players[i]);
			}
		}
		
		var composition_sr = calculate_team_sr(new_composition_players, true);
		var opposite_sr = calculate_team_sr(opposite_team, true);
		var sr_diff = Math.abs( composition_sr - opposite_sr );
		var class_unevenness = calc_class_unevenness( new_composition_players, opposite_team );
		
		// balance target function. Minimum BTF value = best balance
		var class_unevenness_value = Number(document.getElementById("balance_class_uneveness_value").value);
		var btf = Math.round( (class_unevenness*class_unevenness_value + (sr_diff/balance_max_sr_diff*100)*(100-class_unevenness_value))/100, 1 );
		
		// balance restrictions check
		var restrictions_passed = check_balance_restrictions( new_composition_players, opposite_team  );
		
		var new_composition = {
			sr: composition_sr,
			sr_diff: sr_diff,
			players: new_composition_players,
			class_unevenness: class_unevenness,
			btf: btf,
			restrictions: restrictions_passed
		};
		balance_team_combinations.push( new_composition );
		
		if( (btf < best_btf) && restrictions_passed ) {
		//if( btf < best_btf ) {
			best_btf = btf;
			best_btf_index = balance_team_combinations.length-1;
		}
	}
	
	for (var i=last; i<active_players.length; i++) {
		current_team_combination.push( active_players[i] );
		generate_team_combination(i+1);
		current_team_combination.pop();
	}
}

function balance_teams() {
	active_players = team1.concat(team2);
	
	sort_team( active_players );
	
	active_players_total_sr = 0;
	for (var i=0; i<active_players.length; i++ ) {
		active_players_total_sr += calc_player_sr( active_players[i] );
	}
	best_btf = Number.MAX_VALUE;
	best_btf_index = -1;
	
	current_team_combination.splice( 0, current_team_combination.length );
	balance_team_combinations.splice( 0, balance_team_combinations.length );
	
	// start recursive function to generate all possible team combinations
	generate_team_combination(0);
	
	if( best_btf_index >= 0 ) {
		// find all combinations with best BTF value and select random item
		var best_combinations = [];
		for ( i in balance_team_combinations ) {
			if ( (balance_team_combinations[i].btf == best_btf) && balance_team_combinations[i].restrictions ) {
				best_combinations.push( balance_team_combinations[i] );
			}
		}
		best_btf_index = Math.round( Math.random()*(best_combinations.length-1) );
	
		team1.splice( 0, team1.length );
		team2.splice( 0, team2.length );
		
		team1 = best_combinations[best_btf_index].players.slice();
		for (var i=0; i<active_players.length; i++ ) {
			if( team1.indexOf(active_players[i]) == -1 ) {
				team2.push(active_players[i]);
			}
		}
		
		sort_team( team1 );
		sort_team( team2 );
		
		redraw_teams();
	} else {
		alert("Can't find balance with current restricions. Try to change balance settings")
	}
	
	// balance debug
	if ( document.getElementById("balance_dbg").checked ) {
		document.getElementById("balance_dbg_test_result").style.display = "block";
		var res = "#,";
		for (var i=1; i<=team_size; i++ ) {
			res += "player"+i+",";
		}
		res += "=,SR diff,class unevenness,btf,restrictions<br/>";
		
		//balance_team_combinations.sort(function(comb1, comb2){  return comb1.sr_diff-comb2.sr_diff; });
		if (document.getElementById("balance_dbg_sort").checked) {
			balance_team_combinations.sort(function(comb1, comb2){  return comb1.btf-comb2.btf; });
		}
		
		for (var i=0; i<balance_team_combinations.length; i++ ) {
			res += i + ",";
			for (var p=0; p<balance_team_combinations[i].players.length; p++) {
				res = res + balance_team_combinations[i].players[p].display_name + ",";
			}
			res += "=," + balance_team_combinations[i].sr_diff + "," 
				+ balance_team_combinations[i].class_unevenness + ","
				+ balance_team_combinations[i].btf + ","
				+ balance_team_combinations[i].restrictions + "<br/>";
			
		}
		res = res +  "best # " + best_btf_index;
		document.getElementById("balance_dbg_test_result").innerHTML = res;
	}
}	


/*
*		Import / export functions 
*/

function add_player_click() {
	var player_id = document.getElementById("new_player_id").value;
	player_id = player_id.trim().replace("#", "-");
	
	// check duplicates
	var is_duplicate = false;
	for( var i=0; i<team1.length; i++) {
		if( team1[i].id == player_id) {
			is_duplicate = true;
			break;
		}
	}
	if ( ! is_duplicate ) {
		for( var i=0; i<team2.length; i++) {
			if( team2[i].id == player_id) {
				is_duplicate = true;
				break;
			}
		}
	}
	if ( ! is_duplicate ) {
		for( var i=0; i<lobby.length; i++) {
			if( lobby[i].id == player_id) {
				is_duplicate = true;
				document.getElementById(player_id).scrollIntoView( false );
				break;
			}
		}
	}
	
	if ( is_duplicate ) {
		alert("Player already added");
		document.getElementById(player_id).classList.toggle("player-highlighted", true);
		setTimeout( reset_highlighted_players , 2000);
		return;
	}
	
	document.getElementById("add_btn").disabled = true;
	document.getElementById("add_btn").innerHTML = "processing...";
	
	OWAPI.id = player_id;
	OWAPI.onSuccess = add_player_success;
	OWAPI.onFail = add_player_fail;
	OWAPI.getStats();
}

function add_player_success() {
	var new_player = {
		id: OWAPI.id,
		display_name: OWAPI.display_name, 
		sr: OWAPI.sr,
		level: OWAPI.level,
		top_classes: OWAPI.top_classes,
		top_heroes: OWAPI.top_heroes,
	};
	
	var new_player_team;
	var team_selectors = document.getElementsByName("add_team_select");
    for (var i=0; i<team_selectors.length; i++) {
        if (team_selectors[i].checked) {
			if (team_selectors[i].value == "team1") {
				new_player_team = team1;
			} else if (team_selectors[i].value == "team2") {
				new_player_team = team2;
			} else if (team_selectors[i].value == "lobby") {
				new_player_team = lobby;
			} else { // auto team
				if (team1.length < team_size) {
					new_player_team = team1;
				} else {
					new_player_team = team2;
				}
			}
		}
	}
	
	// check if team has free slots
	if ( (new_player_team != lobby) && (new_player_team.length >= team_size) ) {
		new_player_team = lobby;
	}
	
	new_player_team.push(new_player);
	
	document.getElementById("new_player_id").value = "";
	document.getElementById("add_btn").disabled = false;
	document.getElementById("add_btn").innerHTML = "add player";
	
	update_captains();
	
	redraw_teams();
	
	// show and highlight new player
	setTimeout( function() {document.getElementById(new_player.id).scrollIntoView(false);}, 100 );
	setTimeout( function() {highlight_player( new_player.id );}, 500 );
}

function add_player_fail( msg ) {
	document.getElementById("add_btn").disabled = false;
	document.getElementById("add_btn").innerHTML = "add player";
	alert( msg );
}

function export_lobby() {
	init_popup_dlg();
	document.getElementById("popup_dlg").style.display = "block";
	document.getElementById("dlg_title").innerHTML = "Player list export";
	document.getElementById("dlg_import_export_format").style.display = "block";
	document.getElementById("dlg_operation").innerHTML = "Export";
	document.getElementById("dlg_format_value").value = "json";
	document.getElementById("dlg_format_value").onchange = function(event){change_export_format();};
	document.getElementById("dlg_textarea").style.display = "inline";
	document.getElementById("dlg_textarea").select();
	document.getElementById("dlg_textarea").focus();
	
	document.getElementById("dlg_ok").onclick = function(event){close_dialog();};
	
	change_export_format();
}

function import_lobby_dlg() {
	init_popup_dlg();
	document.getElementById("popup_dlg").style.display = "block";
	document.getElementById("dlg_title").innerHTML = "Enter import string";
	document.getElementById("dlg_import_export_format").style.display = "block";
	document.getElementById("dlg_operation").innerHTML = "Import";
	document.getElementById("dlg_format_value").value = "json";
	document.getElementById("dlg_textarea").value = "";
	document.getElementById("dlg_textarea").style.display = "inline";
	document.getElementById("dlg_textarea").select();
	document.getElementById("dlg_textarea").focus();
	
	document.getElementById("dlg_ok").onclick = function(event){close_dialog();import_lobby();};
}

function import_lobby() {
	var import_str = document.getElementById("dlg_textarea").value;
	var added_players = [];

	if (import_str !== null && import_str != "") {
		if ( document.getElementById("dlg_format_value").value == "json" ) {
			try {
				// try to parse json
				var import_struct = JSON.parse(import_str);
				
				for( var i=0; i<import_struct.players.length; i++) {
					// check duplicates
					if (find_player_by_id(import_struct.players[i].id) !== undefined ) {
						continue;
					}
					
					if ( ! Array.isArray(import_struct.players[i].top_classes) ) {
						import_struct.players[i].top_classes = [];
					}
					
					if ( ! Array.isArray(import_struct.players[i].top_heroes) ) {
						import_struct.players[i].top_heroes = [];
					}
					
					lobby.splice(lobby.length, 0, import_struct.players[i]);
					added_players.push( import_struct.players[i].id );
				}
				
				update_captains();
				redraw_teams();
			}
			catch(err) {
				// try to parse as plain battletag list
				alert("Incorrect import format");
				return;
			}
		} else if (document.getElementById("dlg_format_value").value == "battletags") {
			var battletag_list = import_str.trim().split("\n");
			for( i in battletag_list ) {
				var player_id = battletag_list[i].trim();
				player_id = player_id.trim().replace("#", "-");
				var player_name = player_id.slice( 0, player_id.search("-") );
				var new_player = {
						id: player_id,
						display_name: player_name, 
						sr: 0,
						level: 0,
						top_classes: [],
						top_heroes: [],
					};
				lobby.push( new_player );
				players_for_update.push( new_player );
				added_players.push( new_player.id );
			}
			
			update_captains();
			redraw_teams();
			
			// get stats for added players
			total_playets_for_update = players_for_update.length;
			document.getElementById("update_stats_btn").disabled = true;
			document.getElementById("update_stats_btn").value = "↻ Updating stats...1"+" / "+total_playets_for_update;
			update_next_player_stats();
		}
		
		// highlight all new players and scroll to show last one
		setTimeout( function() {document.getElementById( added_players[added_players.length-1] ).scrollIntoView(false);}, 100 );
		setTimeout( function() {highlight_players( added_players );}, 500 );
	}
}

function change_export_format() {
	var export_str = "";
	if ( document.getElementById("dlg_format_value").value == "json" ) {
		var export_struct = {
			format_version: 1,
			players: lobby
			};
		export_str = JSON.stringify(export_struct);
	} else if ( document.getElementById("dlg_format_value").value == "battletags" ) {
		for( i in lobby) {
			var player_id = lobby[i].id.trim().replace("-", "#");
			export_str += player_id + "\n";
		}
	}
	
	document.getElementById("dlg_textarea").value = export_str.trim();
}


/*
*		Settings functions
*/

function save_players_list() {
	// store players to browser local storage
	localStorage.setItem("saved_players", JSON.stringify(lobby));
	localStorage.setItem("saved_players_team1", JSON.stringify(team1));
	localStorage.setItem("saved_players_team2", JSON.stringify(team2));
}

function update_team_size() {
	team_size = Number( document.getElementById("team_size").value );
	redraw_teams();
	localStorage.setItem("team_size", team_size);
}

function update_region() {
	region = document.getElementById("region").value;
	localStorage.setItem("region", region);
}

function save_settings_value( element ) {
	if( element.type == "checkbox" ) {
		localStorage.setItem(element.id, element.checked);
	} else {
		localStorage.setItem(element.id, element.value);
	}
}

function balance_adjust_sr_change() {
	var adjust_enabled = document.getElementById("balance_adjust_sr").checked;
	var inputs = document.getElementById("balance_adjust_sr_sub").getElementsByTagName("INPUT");
	for (var i=0; i<inputs.length; i++ ) {
		inputs[i].disabled = ! adjust_enabled;
	}
	localStorage.setItem( "balance_adjust_sr", adjust_enabled);
}

function restore_team( team, team_name ) {
	var saved_players_json = localStorage.getItem("saved_players"+team_name);
	if ( saved_players_json != null ) {
		var saved_team = JSON.parse(saved_players_json);
		for ( var i in saved_team ) {
			team.push( saved_team[i] );
		}
		
		// delete deprecated fields, add new fields
		for (var i=0; i<team.length; i++) {
			delete team[i].current_sr;
			delete team[i].max_sr;
			
			if ( ! Array.isArray(team[i].top_classes) ) {
				team[i].top_classes = [];
			}
			if ( ! Array.isArray(team[i].top_heroes) ) {
				team[i].top_heroes = [];
			}
		}
	}
}

function enable_captains_change() {
	var captains_enabled = document.getElementById("balance_enable_captains").checked;
	if (captains_enabled) {
		// mark first players as captains
		if (team1.length > 0 ) {
			team1_captain = team1[0].id;
		}
		if (team2.length > 0 ) {
			team2_captain = team2[0].id;
		}
	} else {
		team1_captain = "";
		team2_captain = "";
	}

	redraw_teams();
}

/*
*		Popup dialog
*/

function init_popup_dlg() {
	document.getElementById("dlg_title").innerHTML = "";
	document.getElementById("dlg_import_export_format").style.display = "none";
	document.getElementById("dlg_format_value").onchange = function(event){;};
	document.getElementById("dlg_textarea").style.display = "none";
	document.getElementById("dlg_player_edit").style.display = "none";
	document.getElementById("dlg_player_name_edited").style.visibility = "";
	document.getElementById("dlg_player_sr_edited").style.visibility = "";
	document.getElementById("dlg_player_class1_edited").style.visibility = "";
	document.getElementById("dlg_player_class2_edited").style.visibility = "";
	document.getElementById("dlg_class_select").style.display = "none";
	document.getElementById("dlg_top_heroes").style.display = "none";
	document.getElementById("dlg_update_player_stats").style.display = "none";
	document.getElementById("dlg_ok").onclick = function(event){close_dialog();};
}

function close_dialog() {
	document.getElementById("popup_dlg").style.display = "none";
}

function fill_player_stats_dlg() {
	if (current_player_edit == "") {
		return;
	}
	
	var player_struct = find_player_by_id(current_player_edit);
	
	document.getElementById("dlg_player_id").href = "https://playoverwatch.com/en-us/career/pc/"+region+"/"+player_struct.id;
	document.getElementById("dlg_player_id").innerHTML = player_struct.id;
	
	document.getElementById("dlg_player_display_name").value = player_struct.display_name;
	if( player_struct.ne === true )  {
		document.getElementById("dlg_player_name_edited").style.visibility = "visible";
	} else {
		document.getElementById("dlg_player_name_edited").style.visibility = "";
	}
	
	document.getElementById("dlg_player_sr").value = player_struct.sr;
	if( player_struct.se === true )  {
		document.getElementById("dlg_player_sr_edited").style.visibility = "visible";
	} else {
		document.getElementById("dlg_player_sr_edited").style.visibility = "";
	}
	document.getElementById("dlg_player_level").value = player_struct.level;
	
	if ( Array.isArray(player_struct.top_classes) ) {
		if ( player_struct.top_classes.length > 0 ) {
			document.getElementById("dlg_main_class").value = player_struct.top_classes[0];
		}
		
		if ( player_struct.top_classes.length > 1 ) {
			document.getElementById("dlg_secondary_class").value = player_struct.top_classes[1];
		} else {
			document.getElementById("dlg_secondary_class").value = "";
		}
	}
	
	document.getElementById("dlg_top_heroes_icons").innerHTML = "";
	if ( Array.isArray(player_struct.top_heroes) ) {
		for( i=0; i<player_struct.top_heroes.length; i++ ) {
			var hero_id = player_struct.top_heroes[i].hero;
			if( hero_id == "soldier76") {
				hero_id = "soldier-76";
			}
			var img_node = document.createElement("img");
			img_node.className = "hero-icon";
			img_node.src = "https://blzgdapipro-a.akamaihd.net/hero/"+hero_id+"/hero-select-portrait.png";
			img_node.title = hero_id + "\nPlayed: " + player_struct.top_heroes[i].playtime+" h";
			document.getElementById("dlg_top_heroes_icons").appendChild(img_node);
		}
	}
	
	if( player_struct.ce === true )  {
		document.getElementById("dlg_player_class1_edited").style.visibility = "visible";
		document.getElementById("dlg_player_class2_edited").style.visibility = "visible";
	} else {
		document.getElementById("dlg_player_class1_edited").style.visibility = "";
		document.getElementById("dlg_player_class2_edited").style.visibility = "";
	}
}


/*
*		Other functions
*/

function find_player_by_id(player_id) {
	for( var i=0; i<team1.length; i++) {
		if ( player_id == team1[i].id) {
			return team1[i];
		}
	}
	for( var i=0; i<team2.length; i++) {
		if ( player_id == team2[i].id) {
			return team2[i];
		}
	}
	for( var i=0; i<lobby.length; i++) {
		if ( player_id == lobby[i].id) {
			return lobby[i];
		}
	}
	return undefined;
}

function create_empty_player() {
	return {
			id: "",
			display_name: "",
			sr: 0,
			empty: true
		};
}

function create_random_player( id ) {
	var classes = class_names.slice();
	var top_classes = [];
	top_classes.push( classes.splice( Math.round(Math.random()*(classes.length-1)), 1 )[0] );
	if( Math.random() > 0.4 ) {
		top_classes.push( classes[ Math.round(Math.random()*(classes.length-1)) ] );
	}
	var top_heroes = [];
	return {
			id: "player"+id+"-"+Math.round(Math.random()*99999),
			display_name: "player"+id,
			sr: Math.round(Math.random()*5000),
			level: Math.round(Math.random()*2000),
			empty: false,
			top_classes: top_classes,
			top_heroes: top_heroes
		};
}

function fill_test_teams() {
	// fill teams with ramdom players
	var number_to_add_str = prompt("Enter number of players to generate", 1);

	if (number_to_add_str === null) {
		return;
	}
	var number_to_add = Number(number_to_add_str);
	if( Number.isNaN(number_to_add) ) {
		return;
	}
	if( ! Number.isInteger(number_to_add) ) {
		return;
	}
	
	if( number_to_add > 10000 ) {
		return;
	}

	var added_players = [];
	for( var i=1; i<=number_to_add; i++ ) {
		var new_player = create_random_player(i);
		if ( find_player_by_id(new_player.id) !== undefined ) {
			continue;
		}
		lobby.push( new_player );
		added_players.push( new_player.id );
	}

	redraw_teams();
	
	// highlight all new players and scroll to show last one
	setTimeout( function() {document.getElementById( added_players[added_players.length-1] ).scrollIntoView(false);}, 100 );
	setTimeout( function() {highlight_players( added_players );}, 500 );
}

</script>
</head>
<body >

<div class="page-title">Overwatch custom game balancer</div>
<div class="copyright">2017 by <a href="https://github.com/adminimusRU">l33t m3at</a> | Data from <a href="https://github.com/SunDwarf/OWAPI">OWAPI</a></div>
<br/>


Team size <input id="team_size" name="team_size" type="number" size=3 min=1 max=12 style="width: 3em;" value="" onchange="update_team_size();"/> players. 
Region 
<select id="region" onchange="update_region();">
	<option value="eu">EU</option>
	<option value="us">US</option>
	<option value="kr">KR</option>
</select> 
<br/>
<br/>


<input id="new_player_id" name="new_player_id" type="text" size=35 placeholder="PlayerName#1234 or PlayerName-1234" value="" onkeyup="new_player_keyup(event);"/> 
<button onclick="add_player_click();" id="add_btn" >add player</button> to 

<input class="team-selecor" type="radio" name="add_team_select" id="add_team_select_lobby" value="lobby">
<label for="add_team_select_lobby">lobby</label>

<input class="team-selecor" type="radio" name="add_team_select" id="add_team_select_team1" value="team_1">
<label for="add_team_select_team1">team 1</label> 

<input class="team-selecor" type="radio" name="add_team_select" id="add_team_select_team2" value="team_2">
<label for="add_team_select_team2">team 2</label> 

<input class="team-selecor" type="radio" name="add_team_select" id="add_team_select_auto" value="team_auto" checked>
<label for="add_team_select_auto">auto team</label>

<br/>
<br/>

<div class="table teams">
	<div class="row">
		<div class="cell">
			<div class="team-toolbar">
			<input title="Clear lobby" type="button" class="team_btn" onclick="clear_team(lobby);redraw_teams();" value=" X "/>
			<input title="Import lobby" type="button" class="team_btn" onclick="import_lobby_dlg();" value="Import"/>
			<input title="Export lobby" type="button" class="team_btn" onclick="export_lobby();" value="Export"/>
			<input title="Sort lobby by SR" type="button" class="team_btn" onclick="sort_team(lobby, 'sr');redraw_teams();" value="&uarr;&darr;#"/>
			<input title="Sort lobby by name" type="button" class="team_btn" onclick="sort_team(lobby, 'display_name');redraw_teams();" value="&uarr;&darr;Az"/>
			</div>
		
			<div>
			<span class="team-title">Lobby</span>
			</div>
			
			<span id="lobby_count">0</span> players<br/>
			
			<input id="lobby_filter" class="filter" type="text" size=35 autocomplete="off" placeholder="filter by name or battletag" value="" oninput="lobby_filter_change();"/> 
			
			<div class="lobby-container">
				<div class="table team" id="lobby">

				</div>
			</div>
			
			<br/>
			<div title="Drop player here to delete" class="trashcan" id="trashcan" ondrop="player_drop(event)" ondragover="player_allowDrop(event)">				
				&#9760; Delete player (drop here)
			</div>
		</div>
		
		
		<div class="cell" style="width: 15em">
		<!-- spacer -->
		</div>
	
		<div class="cell">
			<div class="team-toolbar">
			<input title="Clear team" type="button" class="team_btn" onclick="clear_team(team1);redraw_teams();" value=" X "/>
			<input title="Sort team by SR" type="button" class="team_btn" onclick="sort_team(team1, 'sr');redraw_teams();" value="&uarr;&darr;#"/>
			<input title="Sort team by name" type="button" class="team_btn" onclick="sort_team(team1, 'display_name');redraw_teams();" value="&uarr;&darr;Az"/>
			<input title="Move all players to lobby" type="button" class="team_btn" onclick="move_team_to_lobby(team1);redraw_teams();" value="&lt;&lt;"/>
			</div>
			
			<div>
			<input id="team1_name" type="text" class="team-title" value="Team 1" onchange="save_settings_value(this);">
			</div>
			
			<span id="team1_sr">0</span> average SR<br/>
			
			<div class="table team" id="team1" style="background-color: DodgerBlue;">
				<!-- team 1 players -->
			</div>
			
			<br/>
			<div >
			<input class="big-btn" type="button" id="balance_btn" onclick="balance_teams();" value="&#9878; Balance teams" title="Automatically find most balanced compositions"/>
			<br/>
			<br/>
			<input class="big-btn" type="button" id="update_stats_btn" onclick="update_all_stats();" value="&#8635; Update stats" title="Update stats for all players"/>
			
			<br/>
			<br/>
			<input class="big-btn" type="button" onclick="fill_test_teams();" value="Generate random players"/>
			</div>
		</div>
		
		<div class="cell" style="vertical-align: top; padding-top: 10em; min-width: 5em; text-align: center;">
		<br/>
		<span style="font-size: 30pt;"><b><i>VS</i></b></span>
		<br/>
		<br/>
		<input type="button" title="Swap selected players" id="swap_btn" disabled="true" onclick="swap_players();" value="&larr;&rarr;"/>
		</div>
		
		<div class="cell">
			<div class="team-toolbar">
			<input title="Clear team" type="button" class="team_btn" onclick="clear_team(team2);redraw_teams();" value=" X "/>
			<input title="Sort team by SR" type="button" class="team_btn" onclick="sort_team(team2, 'sr');redraw_teams();" value="&uarr;&darr;#"/>
			<input title="Sort team by name" type="button" class="team_btn" onclick="sort_team(team2, 'display_name');redraw_teams();" value="&uarr;&darr;Az"/>
			<input title="Move all players to lobby" type="button" class="team_btn" onclick="move_team_to_lobby(team2);redraw_teams();" value="&lt;&lt;"/>
			</div>
			
			<div>
			<input id="team2_name" type="text" class="team-title" value="Team 2" onchange="save_settings_value(this);">
			</div>
		
			<span id="team2_sr">0</span> average SR<br/>
			
			<div class="table team" id="team2" style="background-color: tomato;">
				<!-- team 2 players -->
			</div>
			
			<br/>
			<div class="group">
				<div class="group-header" onclick="collapse_group(this);">
					<div class="header-icon"><span>+</span></div>
					Balance settings
				</div>
				<div class="group-content group-collapsed">
					<input type="checkbox" id="balance_adjust_sr" onchange="balance_adjust_sr_change();">
					<label for="balance_adjust_sr">Adjust player SR by main class</label>
					</br>
					<div class="subgroup" id="balance_adjust_sr_sub">
						<img src="class_icons/offence.png" style="height: 1em;"/>
						<input disabled id="balance_adjust_sr_offence" class="percent" type="number" size=3 min=0 max=200 autocomplete="off" value="120" onchange="save_settings_value(this);"/>
						% SR for offence mains </br>
						<img src="class_icons/tank.png" style="height: 1em;"/>
						<input disabled id="balance_adjust_sr_tank" class="percent" type="number" size=3 min=0 max=200 autocomplete="off" value="100" onchange="save_settings_value(this);"/>
						% SR for tank mains </br>
						<img src="class_icons/support.png" style="height: 1em;"/>
						<input disabled id="balance_adjust_sr_support" class="percent" type="number" size=3 min=0 max=200 autocomplete="off" value="80" onchange="save_settings_value(this);"/>
						% SR for support mains </br>
						<img src="class_icons/defence.png" style="height: 1em;"/>
						<input disabled id="balance_adjust_sr_defence" class="percent" type="number" size=3 min=0 max=200 autocomplete="off" value="80" onchange="save_settings_value(this);"/>
						% SR for defence mains </br>
					</div>
					</br>
										
					<span>Balance algorithm tuning</span></br>
					<input id="balance_class_uneveness_value" type="range" size=3 min=0 max=100 autocomplete="off" value="70" style="width:90%" onchange="save_settings_value(this);" />
					</br>
					<div style="position: relative; top: -0.5em;margin-left: 1em;margin-right: 1em;">
						<span>equal SR</span>
						<span style="position: absolute;right: 0;">equal classes</span>
					</div>
					</br>
					
					<input type="checkbox" id="balance_separate_otps" onchange="save_settings_value(this);">
					<label for="balance_separate_otps">Do not place similar one-trick ponies into same team</label>
					</br>
					
					<input type="checkbox" id="balance_enable_captains" onchange="enable_captains_change(); save_settings_value(this);">
					<label for="balance_enable_captains">Enable team captains</label>
				</div>
			</div>
			
			</br>
			
			<div class="group">
				<div class="group-header" onclick="collapse_group(this);">
					<div class="header-icon"><span>+</span></div>
					Stats updating settings
				</div>
				<div class="group-content group-collapsed">
					<input type="checkbox" id="update_sr" onchange="save_settings_value(this);" checked>
					<label for="update_sr">Update player SR</label>
					</br>
					<input type="checkbox" id="update_class" onchange="save_settings_value(this);" checked>
					<label for="update_class">Update player class</label>
					</br>
					<input type="checkbox" id="update_edited_fields" onchange="save_settings_value(this);">
					<label for="update_edited_fields">Update manually edited fields (name, SR, class)</label>
					</br>
				</div>
			</div>
			
		</div>
		
		<div class="cell">
			<div class="tips">
				<span class="team-title">&#x2753; Info</span>
				<br>
				<ul>
					<li>Add players by full BattleTag</li>
					<li>Drag & drop players between teams</li>
					<li>Doble click on player to move between lobby and teams</li>
					<li>Right click on player to edit name, SR and class</li>
					<li>Team names are editable</li>
					<li>Player list and all settings are automatically saved in your browser's storage</li>
					<li>You can export and import player list from lobby</li>
					<li>Click 'Balance teams' to automatically swap players between teams for best balance</li>
					<li>Balance algorithm tuning slider:
						<ul>
							<li>In leftmost position balancer will only account SR (as Blizzard do)</li>
							<li>In rightmost position balancer will only account player classes (SR difference can be huge)</li>
							<li>In intermediate position balancer will account both SR and classes in a given proportion</li>
						</ul> 
					</li>
					<li>Click 'Balance teams' again to look through best balance variants</li>
				</ul> 
			</div>
		</div>
	</div>
	

</div>

<div id="popup_dlg" class="dlg" style="display:none">
	<div class="dlg-background"></div>
	<div class="dlg-container">
		<div class="dlg-content">
			<span id="dlg_title" class="team-title">Title</span>
			<input title="Close" type="button" class="team_btn dlg-close" onclick="close_dialog();" value="X"/>
			<br/>
			<br/>
			<div id="dlg_import_export_format" class="dlg_options ">
				<label for=""><span id="dlg_operation">Export</span> format: </label>
				<select id="dlg_format_value">
					<option value="json">JSON (full info)</option>
					<option value="battletags">plain text (BattleTags only)</option>
				</select>
			</div>
			<textarea id="dlg_textarea" rows="10" cols="50"></textarea>
			<div id="dlg_player_edit" class="dlg_options table">
				<div class="row">
					<div class="cell">BattleTag:</div>
					<div class="cell"><a href="" id="dlg_player_id"></a></div>
				</div>
				<div class="row">
					<div class="cell"><label for="dlg_player_display_name">Name:</label></div>
					<div class="cell">
						<input id="dlg_player_display_name" type="text">
						<span id="dlg_player_name_edited" class="dlg-edited-mark" title="Name was manually edited">&#9997;</span>
					</div>
				</div>
				<div class="row">
					<div class="cell"><label for="dlg_player_level">Level:</label></div>
					<div class="cell"><input id="dlg_player_level" type="text" readonly></div>
				</div>
				<div class="row">
					<div class="cell"><label for="dlg_player_sr">SR:</label></div>
					<div class="cell">
						<input id="dlg_player_sr" type="number" min=0 max=5000>
						<span id="dlg_player_sr_edited" class="dlg-edited-mark" title="SR was manually edited">&#9997;</span>
					</div>
				</div>
			</div>
			<div id="dlg_class_select" class="dlg_options table">
				<div class="row">
					<div class="cell">Main class: </div>
					<div class="cell">
						<select id="dlg_main_class">
							<option value="offence">offence</option>
							<option value="tank">tank</option>
							<option value="support">support</option>
							<option value="defence">defence</option>
						</select>
						<span id="dlg_player_class1_edited" class="dlg-edited-mark" title="Classes were manually edited">&#9997;</span>
					</div>
				</div>
				<div class="row">
					<div class="cell">Secondary class: </div>
					<div class="cell">
						<select id="dlg_secondary_class">
							<option value="">-</option>
							<option value="offence">offence</option>
							<option value="tank">tank</option>
							<option value="support">support</option>
							<option value="defence">defence</option>
						</select>
						<span id="dlg_player_class2_edited" class="dlg-edited-mark" title="Classes were manually edited">&#9997;</span>
					</div>
				</div>	
			</div>
			<br/>
			<div id="dlg_top_heroes">
				<span>Top heroes:</span>
				<br/>
				<div id="dlg_top_heroes_icons" class="hero-icon-list"></div>
			</div>
			<br/>
			<input id="dlg_update_player_stats" class="big-btn" type="button" value="&#8635; Update stats" onclick="update_current_player_stats();"/>
			<br/>
			<input id="dlg_ok" class="big-btn" type="button" value="OK"/>
		</div>
	</div>
</div>

<div title="Balance debug" style="display: none;">
Balance debug settings <br/>
<input type="checkbox" title="balance debug out" id="balance_dbg"  autocomplete="off">
<label for="balance_dbg">Print all possible team compositions</label>
<br/>
<input type="checkbox" title="balance debug sort" id="balance_dbg_sort" autocomplete="off">
<label for="balance_dbg_sort">Sort team compositions</label>
</div>

<div id="balance_dbg_test_result" style="display: none;"></div>

<script>
//restore saved players to teams
restore_team( lobby, "" );
restore_team( team1, "_team1" );
restore_team( team2, "_team2" );
redraw_teams();

// restore settings and team names
var settings_list = [
	"team_size",
	"region",
	"team1_name",
	"team2_name",
	"balance_adjust_sr",
	"balance_adjust_sr_offence",
	"balance_adjust_sr_tank",
	"balance_adjust_sr_support",
	"balance_adjust_sr_defence",
	"balance_class_uneveness_value",
	"balance_separate_otps",
	"balance_enable_captains",
	"update_class",
	"update_sr",
	"update_edited_fields"
	];

for ( i in settings_list ) {
	var setting_value = localStorage.getItem(settings_list[i]);
	if( setting_value !== null ) {
		var setting_input = document.getElementById(settings_list[i]);
		if ( setting_input.type == "checkbox" ) {
			setting_input.checked = (setting_value == 'true');
		} else if ( setting_input.type == "text" ) {
			setting_input.value = setting_value;
		} else if ( setting_input.type == "number" ) {
			setting_input.value = Number(setting_value);
		} else if ( setting_input.type == "range" ) {
			setting_input.value = Number(setting_value);
		}
		
		
	}
}

// set default values to inputs
if (document.getElementById("team_size").value == 0 ) {
	document.getElementById("team_size").value = team_size;
}
if (document.getElementById("region").value == "" ) {
	document.getElementById("region").value = region;
}

update_team_size();
update_region();
balance_adjust_sr_change();
enable_captains_change();

update_captains();

</script>

</body>
</html>
